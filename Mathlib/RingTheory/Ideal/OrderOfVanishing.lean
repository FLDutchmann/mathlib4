/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles
-/
import Mathlib.RingTheory.KrullDimension.NonZeroDivisors
import Mathlib.RingTheory.Length
import Mathlib.RingTheory.HopkinsLevitzki

/-!
# Order of vanishing

This file defines the order of vanishing of an element of a ring as the length of the quotient of
the ring by the ideal generated by that element. We also define the extension of this notion to the
field of fractions
-/

open Ring
open LinearMap
open Multiplicative
open Pointwise
open Function
open IsLocalization
open Ideal

variable {R : Type*} [CommRing R] {M : Type*} [AddCommMonoid M] [Module R M]

variable (R) in
/--
Order of vanishing function for elements of a ring.
-/
@[stacks 02MD]
noncomputable
def CommRing.ord (x : R) := Module.length R (R ⧸ Submodule.span (R := R) (M := R) {x})

/--
The order of vanishing of `1` is `0`.
-/
lemma CommRing.ord_one : CommRing.ord R 1 = 0 := by
  simp_all [CommRing.ord, Module.length_eq_zero_iff,
    Ideal.span_singleton_one, Submodule.Quotient.subsingleton_iff]

/-
This doesn't really belong in this file, but I'm leaving it here for the moment because I'm not
convinced this lemma in this form is the right thing to put into mathlib, but I'm not sure exactly
what to do instead.
-/
lemma Submodule.span_quot (a : R) (I : Ideal R) : (a • ⊤ : Submodule R (R ⧸ a • I)) =
   Submodule.span R {Submodule.Quotient.mk a} := by
    ext k
    simp [Submodule.mem_smul_pointwise_iff_exists, mem_span_singleton]
    constructor
    · intro h
      obtain ⟨b, hb⟩ := h
      rw [← hb]
      have : ∃ b' : R, Submodule.Quotient.mk b' = b := Quotient.exists_rep b
      obtain ⟨b', hb'⟩ := this
      use b'
      rw [← hb']
      suffices b' • (Submodule.Quotient.mk (p := a • I) a) = a • Submodule.Quotient.mk b' by exact
        this
      rw[← Submodule.Quotient.mk_smul, ← Submodule.Quotient.mk_smul]
      congr 1
      simp only [smul_eq_mul, mul_comm]
    · intro h
      obtain ⟨b, hb⟩ := h
      use (Ideal.Quotient.mk (a • I) b)
      rw [← hb]
      suffices a • (Submodule.Quotient.mk (p := (a • I))) b =
        b • (Submodule.Quotient.mk (p := (a • I))) a by exact this
      rw [← Submodule.Quotient.mk_smul, ← Submodule.Quotient.mk_smul]
      congr 1
      simp only [smul_eq_mul, mul_comm]
/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a`
-/
def Ideal.mulQuot (a : R) (I : Ideal R) :
    R ⧸ I →ₗ[R] R ⧸ (a • I) :=
      Submodule.mapQ _ _ (LinearMap.mul R R a) <|
        have : a • I = Submodule.map ((LinearMap.mul R R) a) I := rfl ;
        by simp [this, Submodule.comap_map_eq]
/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a` is injective if `a` is
a nonzero divisor.
-/
lemma Ideal.mulQuotInjective {a : R} (I : Ideal R) (ha : a ∈ nonZeroDivisors R) :
  Function.Injective (Ideal.mulQuot a I) := by
  simp only [mulQuot, Submodule.mapQ, ← ker_eq_bot]
  apply Submodule.ker_liftQ_eq_bot'
  apply le_antisymm
  · rw [@le_ker_iff_map]
    have : Submodule.map (mul R R a) I = a • I := rfl
    rw [Submodule.map_comp]
    rw [this]
    exact Submodule.mkQ_map_self (a • I)
  · have m : I = Submodule.comap (mul R R a) (a • I) := by
      ext b
      exact Iff.symm (Submodule.mul_mem_smul_iff ha)
    simp [←m, ker_comp]

lemma Ideal.smul_le_span (s : Set R) (I : Ideal R) : s • I ≤ Ideal.span s :=
  by simp [← Submodule.set_smul_top_eq_span, Submodule.singleton_set_smul, smul_le_smul_left]

/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})`.
-/
def Ideal.quotOfMul (a : R) (I : Ideal R) :
  (R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a}) :=
  Submodule.factor <| Submodule.singleton_set_smul I a ▸ Ideal.smul_le_span {a} I

/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})` is surjective.
-/
lemma Ideal.quotOfMulSurjective {a : R} (I : Ideal R) :
    Function.Surjective (Ideal.quotOfMul a I) := by
    simp only [Ideal.quotOfMul]
    exact Submodule.factor_surjective <|
      Submodule.singleton_set_smul I a ▸ Ideal.smul_le_span {a} I
/--
The sequence `R ⧸ I →ₗ[R] R ⧸ (a • I) →ₗ[R] R ⧸ (Ideal.span {a})` given by multiplication
by a then quotienting by the ideal generated by a is exact.
-/
lemma LinearMap.quotMulExact {a : R} (I : Ideal R) :
  Function.Exact (Ideal.mulQuot a I) (Ideal.quotOfMul a I) := by
  simp [LinearMap.exact_iff]
  have : ker (Ideal.quotOfMul a I) = a • ⊤ := by
    simp only [Ideal.quotOfMul, Submodule.factor, Submodule.mapQ, comp_id, Submodule.ker_liftQ,
      Submodule.ker_mkQ]
    suffices Submodule.map (Submodule.mkQ (a • I)) (Submodule.span R {a}) = a • ⊤ by exact this
    rw [Submodule.map_span]
    simp only [Submodule.mkQ_apply, Quotient.mk_eq_mk, Set.image_singleton, Submodule.span_quot]
  simp [this, Ideal.mulQuot, Submodule.mapQ.eq_1, Submodule.range_liftQ,
   range_comp, Submodule.span_quot, ← Ideal.submodule_span_eq, LinearMap.map_span]

variable (R)
/--
The order of vanishing of a * b is the order of vanishig of a plus the order
of vanishing of b.
-/
theorem CommRing.ord_mul {a b : R}
  (hb : b ∈ nonZeroDivisors R) :
  CommRing.ord R (a*b) = CommRing.ord R a + CommRing.ord R b := by
  have :=  Module.length_eq_add_of_exact (Ideal.mulQuot b (Ideal.span {a}))
          (Ideal.quotOfMul b (Ideal.span {a})) (Ideal.mulQuotInjective (Ideal.span {a}) hb)
          (Ideal.quotOfMulSurjective (Ideal.span {a})) (LinearMap.quotMulExact (Ideal.span {a}))
  simp only [ord, submodule_span_eq, ← this]
  have lem : (({b} : Set R) • Ideal.span {a}) = Ideal.span {b * a} := by
    simp [←Ideal.submodule_span_eq, Submodule.set_smul_span]
  have : (({b} : Set R) • Ideal.span {a}) = b • Ideal.span {a} := Submodule.singleton_set_smul
    (Ideal.span {a}) b
  rw [this] at lem
  rw [lem, mul_comm]

/--
CommMonoidWithZero instance on Multiplicative ℕ∞. Note that since the
operation being considered here is addition, the zero element is not the
natural number 0, but ⊤.
-/
instance : CommMonoidWithZero (Multiplicative ℕ∞) where
  zero := ⊤
  zero_mul _ := rfl
  mul_zero a := add_top (toAdd a)


open Classical in
/--
Monoid with zero homomorpihsm from a ring R to Multiplicative ℕ∞.

Note that we need some case distinction like is given here. This is because if R is finite length,
then ord R 0 will be some non top value, meaninig in this case 0 will not be mapped to ⊤.
-/
@[stacks 02MD]
noncomputable
def CommRing.ordMonoidWithZeroHom [Nontrivial R] : R →*₀ Multiplicative ℕ∞ where
  toFun x := if x ∈ nonZeroDivisors R then CommRing.ord R x else 0
  map_zero' := by
    simp[nonZeroDivisors, exists_ne]
  map_one' := by
    simp[nonZeroDivisors, CommRing.ord_one]
    rfl
  map_mul' := by
    intro x y
    split_ifs
    all_goals simp_all [mul_mem_nonZeroDivisors]
    rename_i a b
    apply CommRing.ord_mul R b
/--
Canonical embedding `Multiplicative ℕ∞ →*₀ ℕₘ₀`.
-/
def ENat.multiplicativeToMulWithZero : Multiplicative ℕ∞ →*₀ ℕₘ₀ where
  toFun n := n
  map_zero' := rfl
  map_one' := rfl
  map_mul' _ _ := rfl

/--
Cast `ℕₘ₀` to `ℤₘ₀`.
-/
noncomputable
def WithZero.castNatMulZeroMonoidWithZeroHom : ℕₘ₀ →*₀ ℤₘ₀ := WithZero.map' <|
  (AddMonoidHom.toMultiplicative).toFun (Nat.castAddMonoidHom ℤ)

/--
Embedding of `Multiplicative ℕ∞` into `ℤₘ₀`.
-/
noncomputable
def ENat.multiplicativeToIntMulWithZero : Multiplicative ℕ∞ →*₀ ℤₘ₀ := MonoidWithZeroHom.comp
  WithZero.castNatMulZeroMonoidWithZeroHom ENat.multiplicativeToMulWithZero

/--
Order of vanishing function for elements of the fraction field defined as the extension of
CommRing.ordMonoidWithZeroHom to the field of fractions.
-/
@[stacks 02MD]
noncomputable
def CommRing.ordFrac [Nontrivial R] {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]
    (hR : ∀ y : nonZeroDivisors R, ENat.multiplicativeToMulWithZero (CommRing.ord R y.1) ≠ 0) :
    K →*₀ ℤₘ₀ :=
  letI f := Submonoid.LocalizationWithZeroMap.lift (toLocalizationWithZeroMap (nonZeroDivisors R) K)
    (MonoidWithZeroHom.comp ENat.multiplicativeToIntMulWithZero (CommRing.ordMonoidWithZeroHom R))
  haveI : (∀ (y : ↥(nonZeroDivisors R)),
    IsUnit ((ENat.multiplicativeToIntMulWithZero.comp (CommRing.ordMonoidWithZeroHom R)) ↑y)) := by
    intro y
    simp only [ENat.multiplicativeToIntMulWithZero, WithZero.castNatMulZeroMonoidWithZeroHom,
      Equiv.toFun_as_coe, ENat.multiplicativeToMulWithZero, MonoidWithZeroHom.coe_comp,
      MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, isUnit_iff_ne_zero, ne_eq]
    intro a
    have : ∃ a : Multiplicative ℕ, WithZero.coe a = ((CommRing.ordMonoidWithZeroHom R) y.1) := by
      specialize hR y
      refine WithZero.ne_zero_iff_exists.mp ?_
      simp only [CommRing.ordMonoidWithZeroHom, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk,
        SetLike.coe_mem, ↓reduceIte, ne_eq]
      exact hR
    obtain ⟨m, hm⟩ := this
    rw [← hm] at a
    simp at a

  f this

/--
The order of vanishing is finite for all elements of
Noetherian rings of Krull dimension less than or equal to 1.
-/
theorem CommRing.ord_finite [IsNoetherianRing R]
         (hR : ringKrullDim R ≤ 1) {x : R} (hx : x ∈ nonZeroDivisors R) :
         IsFiniteLength R (R ⧸ Ideal.span {x}) := by
  rw[isFiniteLength_iff_isNoetherian_isArtinian]
  constructor
  · exact isNoetherian_quotient (Ideal.span {x})
  · by_cases o : IsArtinianRing R
    · exact isArtinian_of_quotient_of_artinian (Ideal.span {x})
    · have := ringKrullDim_quotient_succ_le_of_nonZeroDivisor hx
      have : ringKrullDim (R ⧸ Ideal.span {x}) ≤ 0 := by
        have : ringKrullDim (R ⧸ Ideal.span {x}) + 1 ≤ 1 :=
          Preorder.le_trans (ringKrullDim (R ⧸ Ideal.span {x}) + 1) (ringKrullDim R) 1 this hR
        /-
        Note: I don't really think this is the right approach to proving this stuff about arithmetic
        in ENat, but I wasn't quite sure what the best lemma to pull out from here would be.
        -/
        by_cases o : ringKrullDim (R ⧸ Ideal.span {x}) = ⊤
        · simp_all
          have rwlem : (⊤ : WithBot (ℕ∞)) + 1 = ⊤ := rfl
          simp[rwlem] at this
          have thing : 1 ≠ (⊤ : WithBot ℕ∞) := by exact ne_of_beq_false rfl
          exact False.elim (thing this)
        · by_cases o' : ringKrullDim (R ⧸ Ideal.span {x}) = ⊥
          · rw[o']
            exact OrderBot.bot_le 0
          · obtain ⟨d, hd⟩ := WithBot.ne_bot_iff_exists.mp o'
            have c : d ≠ ⊤ := by
              rw[← hd] at o
              exact fun a ↦ o (congrArg WithBot.some a)
            obtain ⟨d', hd'⟩ := WithTop.ne_top_iff_exists.mp c
            suffices d ≤ 0 by
              rw[← hd]
              exact WithBot.coe_le_zero.mpr this
            suffices d' ≤ 0 by
              rw[← hd']
              aesop
            have : d + 1 ≤ 1 := by
              rw[←hd] at this
              exact WithBot.coe_le_one.mp this
            have : d' + 1 ≤ 1 := by
              rw[← hd'] at this
              exact ENat.coe_le_coe.mp this
            omega
      have : Ring.KrullDimLE 0 (R ⧸ Ideal.span {x}) :=
        (Order.krullDimLE_iff 0 (PrimeSpectrum (R ⧸ Ideal.span {x}))).mpr this

      have : IsArtinian (R ⧸ Ideal.span {x}) ((R ⧸ Ideal.span {x})) :=
        IsNoetherianRing.isArtinianRing_of_krullDimLE_zero

      apply (OrderEmbedding.wellFoundedLT (β := Submodule (R ⧸ Ideal.span {x})
        (R ⧸ Ideal.span {x})) _)
      refine ⟨⟨?_, ?_⟩, ?_⟩
      · intro N
        refine {toAddSubmonoid := N.toAddSubmonoid, smul_mem' := ?_}
        intro c x hx
        obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective c
        show r • x ∈ N
        apply N.smul_mem _ hx
      · intro N1 N2 h
        rwa[Submodule.ext_iff] at h ⊢
      · intro N1 N2
        rfl

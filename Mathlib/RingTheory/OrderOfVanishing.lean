/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles
-/
import Mathlib.RingTheory.KrullDimension.NonZeroDivisors
import Mathlib.RingTheory.Length
import Mathlib.RingTheory.HopkinsLevitzki

/-!
# Order of vanishing

This file defines the order of vanishing of an element of a ring as the length of the quotient of
the ring by the ideal generated by that element. We also define the extension of this notion to the
field of fractions
-/

open LinearMap Multiplicative Pointwise IsLocalization Ideal

variable {R : Type*} {M : Type*} [AddCommMonoid M]

namespace Ring

variable (R) [Ring R]
/--
Order of vanishing function for elements of a ring.
-/
@[stacks 02MD]
noncomputable
def ord (x : R) : ℕ∞ := Module.length R (R ⧸ Ideal.span {x})

/--
The order of vanishing of `1` is `0`.
-/
lemma ord_one : ord R 1 = 0 := by
  simp_all [ord, Module.length_eq_zero_iff,
    Ideal.span_singleton_one, Submodule.Quotient.subsingleton_iff]

end Ring

section CommRing

variable [CommRing R] [Module R M]

lemma Ideal.Quotient.smul_top (a : R) (I : Ideal R) :
    (a • ⊤ : Submodule R (R ⧸ I)) = Submodule.span R {Submodule.Quotient.mk a} := by
  simp [← Ideal.Quotient.span_singleton_one, Algebra.smul_def, Submodule.smul_span]
/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a`
-/
def Ideal.mulQuot (a : R) (I : Ideal R) :
    R ⧸ I →ₗ[R] R ⧸ (a • I) :=
      Submodule.mapQ _ _ (LinearMap.mul R R a) (Submodule.le_comap_map _ _)

/--
The map `R ⧸ I →ₗ[R] R ⧸ (a • I)` defined by multiplication by `a` is injective if `a` is
a nonzero divisor.
-/
lemma Ideal.mulQuotInjective {a : R} (I : Ideal R) (ha : a ∈ nonZeroDivisors R) :
  Function.Injective (Ideal.mulQuot a I) := by
  simp only [mulQuot, Submodule.mapQ, ← ker_eq_bot]
  apply Submodule.ker_liftQ_eq_bot'
  apply le_antisymm
  · rw [@le_ker_iff_map]
    have : Submodule.map (mul R R a) I = a • I := rfl
    rw [Submodule.map_comp]
    rw [this]
    exact Submodule.mkQ_map_self (a • I)
  · have m : I = Submodule.comap (mul R R a) (a • I) := by
      ext b
      exact Iff.symm (Submodule.mul_mem_smul_iff ha)
    simp [←m, ker_comp]

lemma Ideal.smul_le_span (s : Set R) (I : Ideal R) : s • I ≤ Ideal.span s :=
  by simp [← Submodule.set_smul_top_eq_span, Submodule.singleton_set_smul, smul_le_smul_left]

/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})`.
-/
def Ideal.quotOfMul (a : R) (I : Ideal R) :
  (R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a}) :=
  Submodule.factor <| Submodule.singleton_set_smul I a ▸ Ideal.smul_le_span {a} I

/--
The quotient map `(R ⧸ a • I) →ₗ[R] (R ⧸ Ideal.span {a})` is surjective.
-/
lemma Ideal.quotOfMulSurjective {a : R} (I : Ideal R) :
    Function.Surjective (Ideal.quotOfMul a I) := by
    simp only [Ideal.quotOfMul]
    exact Submodule.factor_surjective <|
      Submodule.singleton_set_smul I a ▸ Ideal.smul_le_span {a} I
/--
The sequence `R ⧸ I →ₗ[R] R ⧸ (a • I) →ₗ[R] R ⧸ (Ideal.span {a})` given by multiplication
by `a` then quotienting by the ideal generated by `a` is exact.
-/
lemma LinearMap.quotMulExact {a : R} (I : Ideal R) :
  Function.Exact (Ideal.mulQuot a I) (Ideal.quotOfMul a I) := by
  simp only [exact_iff]
  have : ker (Ideal.quotOfMul a I) = a • ⊤ := by
    simp only [Ideal.quotOfMul, Submodule.factor, Submodule.mapQ, comp_id, Submodule.ker_liftQ,
      Submodule.ker_mkQ]
    suffices Submodule.map (Submodule.mkQ (a • I)) (Submodule.span R {a}) = a • ⊤ by exact this
    rw [Submodule.map_span]
    simp only [Submodule.mkQ_apply, Quotient.mk_eq_mk, Set.image_singleton, Ideal.Quotient.smul_top]
  simp [this, Ideal.mulQuot, Submodule.mapQ.eq_1, Submodule.range_liftQ,
   range_comp, Ideal.Quotient.smul_top, ← Ideal.submodule_span_eq, LinearMap.map_span]

variable (R)
/--
The order of vanishing of `a * b` is the order of vanishing of `a` plus the order
of vanishing of `b`.
-/
theorem CommRing.ord_mul {a b : R}
  (hb : b ∈ nonZeroDivisors R) :
  Ring.ord R (a*b) = Ring.ord R a + Ring.ord R b := by
  have :=  Module.length_eq_add_of_exact (Ideal.mulQuot b (Ideal.span {a}))
          (Ideal.quotOfMul b (Ideal.span {a})) (Ideal.mulQuotInjective (Ideal.span {a}) hb)
          (Ideal.quotOfMulSurjective (Ideal.span {a})) (LinearMap.quotMulExact (Ideal.span {a}))
  simp only [Ring.ord, submodule_span_eq, ← this]
  have lem : (({b} : Set R) • Ideal.span {a}) = Ideal.span {b * a} := by
    simp [←Ideal.submodule_span_eq, Submodule.set_smul_span]
  have : (({b} : Set R) • Ideal.span {a}) = b • Ideal.span {a} := Submodule.singleton_set_smul
    (Ideal.span {a}) b
  rw [this] at lem
  rw [lem, mul_comm]

open Classical in
/--
Monoid with zero homomorpihsm from a nontrivial commutative ring `R` to `ℕₘ₀`.

Note that we cannot just use `fun x ↦ ord R x` without further assumptions on `R`.
This is because if R is finite length, then ord R 0 will be some non top value,
meaning in this case `0` will not be mapped to `⊤`.
-/
@[stacks 02MD]
noncomputable
def CommRing.ordMonoidWithZeroHom [Nontrivial R] : R →*₀ ℕₘ₀ where
  toFun x := if x ∈ nonZeroDivisors R then Ring.ord R x else 0
  map_zero' := by
    simp [nonZeroDivisors, exists_ne]
  map_one' := by
    simp [nonZeroDivisors, Ring.ord_one]
    rfl
  map_mul' := by
    intro x y
    split_ifs
    · rename_i a b
      apply CommRing.ord_mul R b
    all_goals simp_all [mul_mem_nonZeroDivisors]

/--
Cast `ℕₘ₀` to `ℤₘ₀`.
-/
noncomputable
def WithZero.castNatMulZeroMonoidWithZeroHom : ℕₘ₀ →*₀ ℤₘ₀ := WithZero.map' <|
  (AddMonoidHom.toMultiplicative).toFun (Nat.castAddMonoidHom ℤ)

/--
If `M` is an Artinian `R` module, and `S` is an `R`-algebra with a surjective
algebra map, then `M` is an Artinian `S` module.
-/
theorem IsArtinian.of_surjective_algebraMap {R S M : Type*}
    [CommRing R] [CommRing S] [AddCommGroup M] [Algebra R S] [Module R M] [Module S M]
    [IsArtinian S M] [IsScalarTower R S M] (H : Function.Surjective (algebraMap R S)) :
    IsArtinian R M := by
  apply (OrderEmbedding.wellFoundedLT (β := Submodule S M))
  refine ⟨⟨?_, ?_⟩, ?_⟩
  · intro N
    refine {toAddSubmonoid := N.toAddSubmonoid, smul_mem' := ?_}
    intro c x hx
    obtain ⟨r, rfl⟩ := H c
    suffices r • x ∈ N by simpa [Algebra.algebraMap_eq_smul_one, smul_assoc]
    apply N.smul_mem _ hx
  · intro N1 N2 h
    rwa [Submodule.ext_iff] at h ⊢
  · intro N1 N2
    rfl

/--
Addition in `WithBot (WithTop α)` is right cancellative provided the element
being cancelled is not `⊤` or `⊥`.
-/
lemma WithBot.add_le_add_iff_right' {α : Type*} [Add α] [LE α]
    [AddRightMono α] [AddRightReflectLE α]
    {a b c : WithBot (WithTop α)} (hc : c ≠ ⊥) (hc' : c ≠ ⊤) :
    a + c ≤ b + c ↔ a ≤ b := by
  induction a <;> induction b <;> induction c <;> norm_cast at * <;>
    aesop (add simp WithTop.add_le_add_iff_right)

/--
The order of vanishing is finite for all elements of
Noetherian rings of Krull dimension less than or equal to `1`.
-/
theorem CommRing.ord_finite [IsNoetherianRing R]
         (hR : ringKrullDim R ≤ 1) {x : R} (hx : x ∈ nonZeroDivisors R) :
         IsFiniteLength R (R ⧸ Ideal.span {x}) := by
  rw [isFiniteLength_iff_isNoetherian_isArtinian]
  suffices IsArtinianRing (R ⧸ Ideal.span {x}) from
    ⟨isNoetherian_quotient (Ideal.span {x}),
      .of_surjective_algebraMap (Ideal.Quotient.mk_surjective (I := .span {x}))⟩
  rw [isArtinianRing_iff_krullDimLE_zero, Ring.KrullDimLE, Order.krullDimLE_iff,
    ← WithBot.add_le_add_iff_right' (c := 1) (by simp) (WithBot.coe_eq_coe.not.mpr (by simp)),
    Nat.cast_zero, zero_add]
  exact (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hx).trans hR

/--
Order of vanishing function for elements of the fraction field defined as the extension of
`CommRing.ordMonoidWithZeroHom` to the field of fractions.
-/
@[stacks 02MD]
noncomputable
def CommRing.ordFrac [Nontrivial R] {K : Type*} [Field K] [Algebra R K] [IsFractionRing R K]
    [IsNoetherianRing R] (hR : ringKrullDim R ≤ 1) : K →*₀ ℤₘ₀ :=
  letI f := Submonoid.LocalizationWithZeroMap.lift (toLocalizationWithZeroMap (nonZeroDivisors R) K)
    (MonoidWithZeroHom.comp WithZero.castNatMulZeroMonoidWithZeroHom
    (CommRing.ordMonoidWithZeroHom R))
  haveI : (∀ (y : ↥(nonZeroDivisors R)),
    IsUnit ((WithZero.castNatMulZeroMonoidWithZeroHom.comp
    (CommRing.ordMonoidWithZeroHom R)) ↑y)) := by
    intro y
    simp only [WithZero.castNatMulZeroMonoidWithZeroHom , WithZero.castNatMulZeroMonoidWithZeroHom,
      Equiv.toFun_as_coe, MonoidWithZeroHom.coe_comp,
      MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, isUnit_iff_ne_zero, ne_eq]
    intro a
    have : ∃ a : Multiplicative ℕ, WithZero.coe a = ((CommRing.ordMonoidWithZeroHom R) y.1) := by
      simp only [ordMonoidWithZeroHom, Ring.ord, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk,
        SetLike.coe_mem, ↓reduceIte, Multiplicative.exists]
      have := Module.length_ne_top_iff.mpr <| CommRing.ord_finite R hR y.2
      exact ENat.ne_top_iff_exists.mp this
    obtain ⟨m, hm⟩ := this
    rw [← hm] at a
    simp at a
  f this

end CommRing
